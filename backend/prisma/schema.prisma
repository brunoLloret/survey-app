// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init


// This prisma schema should guarantee confidentiality yet ensure:
// 1) Maximum amount of metadata for further analysis
// 2) Traceability through other means

// On the other hand, although in this project there is no auth, therefore no distinction between users,
//it would be useful for a real-life app to actually track who created what survey.

// User -> Create a survey
// User -> Answer a survey
// User -> Modify a survey
// User -> Decide whether that modification will delete the stored answers of a question that no longer exists
// User -> Save a draft of a survey and continue later
// User -> See saved drafts (they have a limit of 72 hours, or adjustable)
// User -> See results and diverse formats of those results

// User -> Create a survey
  // Survey -> Questions
    // Questions -> Questions | Answers

// User -> Answer a survey
// User -> Modify a survey
// User -> Decide whether that modification will delete the stored answers of a question that no longer exists
// User -> Save a draft of a survey and continue later
// User -> See saved drafts (they have a limit of 72 hours, or adjustable)
// User -> See results and diverse formats of those results


// User to Survey relationships to consider:


// User as creator (1:many)
// User as respondent (many:many)
// Need to track survey ownership vs responses


// Survey to Question considerations:


// Questions need position/order tracking
// Version management for modifications
// Handling nested questions (from your matrix design)
// Parent-child relationships for nested structures


// Question to Answer relationships:


// One question can have multiple answers from different users
// Need to maintain anonymity while preventing duplicate responses
// Consider how to handle modified questions
// Matrix answer storage strategy


// Temporal aspects to consider:


// Survey active/inactive periods
// Answer submission timestamps
// Question modification history
// Draft expiration tracking


// Integrity constraints:


// What happens when a user is deleted?
// How to handle survey deletion with existing responses
// Question modification impact on existing answers

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Survey {
  id          String           @id @default(uuid())
  title       String
  description String?
  status      SurveyStatus    @default(draft)
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  sections    Section[]       // One-to-many relationship with sections
  responses   SurveyResponse[]

  @@map("survey")
}

model Section {
  id          String    @id @default(uuid())
  title       String
  orderIndex  Int       // To maintain section order within a survey
  survey      Survey    @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  surveyId    String
  questions   Question[] // One-to-many relationship with questions
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@map("section")
  @@index([surveyId])
}

model Question {
  id          String       @id @default(uuid())
  label       String
  required    Boolean      @default(false)
  type        QuestionType
  section     Section      @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  sectionId   String
  orderIndex  Int         // To maintain question order within a section
  question    String?     
  placeholder String?     
  maxLength   Int?        
  checked     Boolean?    
  options     Option[]    
  responses   QuestionResponse[]

  @@map("question")
  @@index([sectionId])
}

model Option {
  id          String    @id @default(uuid())
  label       String
  value       String?
  question    Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionId  String
  parentId    String?   
  parent      Option?   @relation("NestedOptions", fields: [parentId], references: [id])
  children    Option[]  @relation("NestedOptions")
  responses   QuestionResponse[] @relation("OptionResponses")

  @@map("option")
  @@index([questionId])
}

model SurveyResponse {
  id            String               @id @default(uuid())
  survey        Survey               @relation(fields: [surveyId], references: [id])
  surveyId      String
  status        SurveyResponseStatus @default(partial)
  submittedAt   DateTime?
  answers       QuestionResponse[]

  @@map("survey_response")
  @@index([surveyId])
}

model QuestionResponse {
  id               String          @id @default(uuid())
  surveyResponse   SurveyResponse  @relation(fields: [surveyResponseId], references: [id], onDelete: Cascade)
  surveyResponseId String
  question         Question        @relation(fields: [questionId], references: [id])
  questionId       String
  textValue       String?         
  booleanValue    Boolean?        
  selectedOptions  Option[]        @relation("OptionResponses")

  @@map("question_response")
  @@index([questionId])
  @@index([surveyResponseId])
}

enum QuestionType {
  checkbox
  radio
  dropdown
  open
  matrix
}

enum SurveyStatus {
  draft
  published
  closed
}

enum SurveyResponseStatus {
  complete
  partial
  invalid
}